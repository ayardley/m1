TODO
====

What's working?
---------------
* simple declarations and initializations (int x; int y = 1;).
* simple assignments (x = 42;).
* while loops
* do-while loops
* if-statements
* for-statements
* break statements (in loops)
* !, && and || logical operators.
* math expressions (+, -, /, etc.)
* != and == operators.

What's not working?
-------------------
* function calls (mostly the returns); parameters/arguments.
* namespaces
* PMC and struct definitions (incl methods)
* return statements
* switch statements
* boolean expressions (e.g., >, <)
* advanced field access (a.b, a->b, etc.)
* pointers, objects (int *x;), null, new.m
* arrays (and initializations)
* self, super
* type checking (separate phase of compiler)
* import statement.
* try/catch statement (needed?)



short-term roadmap:
-------------------
* [FIXED?] implement assignments (x=1). This includes symbol management (sym tables). HIGH PRIORITY
* implement function calls properly (including returning from a function) HIGH PRIORITY
* [FIXED?] finish up control statements (if, while, dowhile, break)
* implement "new" statement for allocating PMC and struct instances. This includes implementing pointers
* implement field access (x.y = 1)
* look into vtable implementation for PMCs for calling member functions x.y();
* think about a module management system. No preprocessor please. Maybe similar to Java's import statement. This might include namespaces, and also private and public scopes for modules (keywords needed?)


random list of items:
---------------------
* implement parameter and argument handling
* implement namespaces and their handling
* implement pointers properly in the parser
* implement structs or other aggregate types; PMCs native?
* any other keywords? e.g., continue? 
* implement semantic checker (a thorough one!)
* finish code generator
* [FIXED] implement constant and variable declarations
* do we want member functions: x.y(); ? (prob for PMCs)
* exception handling at this level?
* [FIXED] make compiler re-entrant
* improve symbol table handling
* free all memory after done.
* an optimizer, perhaps implemented in yet another bison-based grammar; based on certain patterns of intructions that are generated, some instructions can be removed. 
* A register allocator (linear-scan algorithm), to minimize register usage.
