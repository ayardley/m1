
/* manual symbol table
I0	a
S0	b
I23	c
I1	d
*/

void caller() {
	a = 1;
	b = "1..7\n";
	print(b);
	b = "ok 1 control flow in 'caller' at start\n";
	print(b);

	c = 39 * 256 + 15;
	d = 9999;
	d = d - c;
	
	if (d == 0) {
		print("n");
	}
	else {
		print("ok 2 before invocation, caller's I23 is 9999 (got ");
	}

	print(d);
	print(")\n");

	// create a new call frame

	// allocate a new call frame for the gc
	I10 = 8 * 256;
	CallFrame cf = malloc(I10);
	
	// init_cf_copy
	cf[INTERP] = INTERP;
	cf[CHUNK]  = CHUNK;
	cf[CONSTS] = CONSTS;
	cf[MDS]    = MDS;
	cf[BCS]    = BCS;
	cf[PCF]	   = PCF;
	cf[CF]	   = cf;

	// init cf zero
	cf[EH]      = 0;
	cf[RETPC]   = 0;
	cf[SPILLCF] = 0;

	// init cf retpc
	RETPC = PC + 10;

	// init cf pc:
	cf[PC] = PC + 3;
	// activate the new call frame and goto the callee chunk
	CF = cf;

	//post_set
	cf = &callee;
	// put the target PC into I0	
	I0 = 0
	goto_chunk cf, I0

	//  # We're back, so fix the parent call frame's PC and activate it.
	//  # The current CF's CHUNK, CONSTS, etc are updated by goto_chunk, so use
	//  # those values to update PCF.

	//retpc:
	//restore_cf:
	PCF[CHUNK]  = CHUNK;
	PCF[CONSTS] = CONSTS;
	PCF[MDS]    = MDS;
	PCF[BCS]    = BCS;

	//set_cf_pc:
	//    # Set PCF[PC] to the invoke_cf + 1 so that when we invoke PCF with
	//    # "set CF, PCF, x", control flow will continue at the next instruction.
	PCF[PC] = PC + 5;
	PCF[CF] = PCF;	

// invoke_cf:
	CF = PCF;
	print("ok 6 caller back from goto_chunk\n");

	print(CONSTS[2]);
	print("ok 7 value of I23 is restored to 9999 (got ");
	print(I23);
	print(S2);
	exit(0);
}

void callee() {
	print("ok 3 got to callee chunk\n");
	I23 = 99 * 256 + 99;
	I1 = 25443
	I1 = 25443 - I23;
	if (I1 > 0) {
		print("n");
	}
	print("ok 4 callee's I23 is 25443 (got ");
	print(I23);
	print("\n");
	print("\n");
	
	// poke into the parent call frame.
	I2 = PCF[I23];
	I1 = 9999;
	I1 = I1 - I2;
	if (I1 > 0) {
		print("n");
	}
	print("ok 5 in callee, callee's parent's cf's I23 is 9999 (got ");
	print(I2);
	print(")\n");

	// figure out return PC and chunk
	// P0 is the parent call frame.
	I3 = PCF;
	P0 = CF[PCF];
	// I4 is parent call frame's RETPC
	I4 = RETPC;
	I4 = P0[RETPC];
	// S3 is the parent call frame's chunk
	I3 = CONSTS[CHUNK];
	goto_chunk I3, I4

	// this should be unreachable
	print("OH NOES!  Contol flow misflowed!\n");
	
}